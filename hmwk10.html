<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 10 | Statistics - Sapienza University of Rome</title>
    <link rel="stylesheet" href="/statistics/styles.css">
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(','\\)'], ['$', '$']],
                displayMath: [['\\[','\\]'], ['$$','$$']]
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <nav>
        <div class="nav-container">
            <a href="/statistics/index.html" class="logo">STATISTICS</a>
            <ul class="nav-menu">
                <li><a href="/statistics/index.html#home">Home</a></li>
                <li><a href="/statistics/hmwk2.html">HMWK 2</a></li>
                <li><a href="/statistics/hmwk3.html">HMWK 3</a></li>
                <li><a href="/statistics/hmwk4.html">HMWK 4</a></li>
                <li><a href="/statistics/hmwk5.html">HMWK 5</a></li>
                <li><a href="/statistics/hmwk6.html">HMWK 6</a></li>
                <li><a href="/statistics/hmwk7.html">HMWK 7</a></li>
                <li><a href="/statistics/hmwk8.html">HMWK 8</a></li>
                <li><a href="/statistics/hmwk9.html">HMWK 9</a></li>
                <li><a href="/statistics/hmwk10.html">HMWK 10</a></li>
            </ul>
            <div class="hamburger" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        <div class="mobile-menu">
            <ul>
                <li><a href="/statistics/index.html#home" onclick="toggleMenu()">Home</a></li>
                <li><a href="/statistics/hmwk2.html" onclick="toggleMenu()">HMWK 2</a></li>
                <li><a href="/statistics/hmwk3.html" onclick="toggleMenu()">HMWK 3</a></li>
                <li><a href="/statistics/hmwk4.html" onclick="toggleMenu()">HMWK 4</a></li>
                <li><a href="/statistics/hmwk5.html" onclick="toggleMenu()">HMWK 5</a></li>
                <li><a href="/statistics/hmwk6.html" onclick="toggleMenu()">HMWK 6</a></li>
                <li><a href="/statistics/hmwk7.html" onclick="toggleMenu()">HMWK 7</a></li>
                <li><a href="/statistics/hmwk8.html" onclick="toggleMenu()">HMWK 8</a></li>
                <li><a href="/statistics/hmwk9.html" onclick="toggleMenu()">HMWK 9</a></li>
                <li><a href="/statistics/hmwk10.html" onclick="toggleMenu()">HMWK 10</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <section class="hero-section">
            <div class="container">
                <div class="section-number">01</div>
                <div class="section-label">HOMEWORK 10</div>
                <div class="hero-content">
                    <h1>Simulation o a counting process (Poisson process)</h1>
                    <div class="hero-underline"></div>
                    <p class="hero-description">
                        This assignment explores one of the most important <b>stochastic processes</b> in probability 
                        theory: the <b>Poisson process</b>. We simulate a counting process where events occur 
                        independently and uniformly over time at a constant average rate \( \lambda \). By dividing 
                        a time interval into many small subintervals and generating events with probability 
                        \( \lambda/n \), we construct a discrete approximation that converges to the continuous 
                        Poisson process.

                        <div class="math-block">\[ N(t) \sim \text{Poisson}(\lambda t), \quad P(N(t) = k) = \frac{(\lambda t)^k e^{-\lambda t}}{k!} \]</div>

                        Through simulation and theoretical analysis, we reveal the fundamental properties of this 
                        process: <b>independent increments</b>, <b>stationary increments</b>, and <b>memorylessness</b>, 
                        making it the canonical model for random events occurring over time.
                    </p>
                </div>
                <div class="scroll-indicator">
                    <div class="line"></div>
                    <div class="line"></div>
                    <div class="line"></div>
                    <div class="line"></div>
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container">
                <div class="section-number">02</div>

                <div class="content-wrapper">
                    <h2>The Poisson Process</h2>
                    
                    <p>
                        A <b>counting process</b> \( \{N(t), t \geq 0\} \) counts events occurring over time, 
                        where \( N(t) \) represents the total number of events by time \( t \). The <b>Poisson process</b> 
                        is characterized by events occurring:
                    </p>

                    <div class="content-columns">
                        <div class="column">
                            <h3>Key Characteristics</h3>
                            <ul>
                                <li><b>Independently:</b> Events in disjoint time intervals are independent</li>
                                <li><b>Uniformly:</b> Events are equally likely at any point in time</li>
                                <li><b>At constant rate:</b> Average rate \( \lambda \) per unit time</li>
                            </ul>
                            <p>
                                For the Poisson process, the number of events in any interval follows a Poisson distribution:
                            </p>
                            <div class="math-block">\[ N(t) \sim \text{Poisson}(\lambda t) \]</div>
                        </div>

                        <div class="column">
                            <h3>Applications</h3>
                            <p>
                                Counting processes model many real-world phenomena:
                            </p>
                            <ul>
                                <li>Network packet arrivals</li>
                                <li>Customer arrivals in queues</li>
                                <li>Radioactive decay events</li>
                                <li>Security incidents and login attempts</li>
                                <li>Insurance claims</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container">
                <div class="section-number">03</div>

                <div class="content-wrapper">
                    <h2>Simulation Methodology</h2>
                    
                    <p>
                        We simulate a Poisson process by approximating continuous time with discrete subintervals. 
                        This approach builds on the fundamental connection between the binomial and Poisson distributions.
                    </p>

                    <h3>Discretization Approach</h3>

                    <div class="content-columns">
                        <div class="column">
                            <h4>Step 1: Divide the Time Interval</h4>
                            <p>
                                Consider a time interval \([0, T]\). Divide it into \( n \) equal subintervals, 
                                each of length:
                            </p>
                            <div class="math-block">\[ \Delta t = \frac{T}{n} \]</div>
                            <p>
                                For example, if \( T = 1 \) and \( n = 5000 \), then \( \Delta t = 0.0002 \).
                            </p>
                            <p>
                                The subintervals are:
                            </p>
                            <div class="math-block">\[ [0, \Delta t], (\Delta t, 2\Delta t], (2\Delta t, 3\Delta t], \ldots, ((n-1)\Delta t, n\Delta t] \]</div>
                        </div>

                        <div class="column">
                            <h4>Step 2: Generate Events</h4>
                            <p>
                                In each subinterval, we generate an event (success) with probability:
                            </p>
                            <div class="math-block">\[ p = \frac{\lambda}{n} = \lambda \Delta t \]</div>
                            <p>
                                where \( \lambda \) is the desired average rate of events per unit time.
                            </p>
                            <p>
                                <b>Implementation:</b> For each of the \( n \) subintervals:
                            </p>
                            <ul>
                                <li>Generate a random number \( U \sim \text{Uniform}(0,1) \)</li>
                                <li>If \( U < p \), record an event at that subinterval</li>
                                <li>Otherwise, no event occurs</li>
                            </ul>
                        </div>
                    </div>

                    <h3>Why This Works: From Binomial to Poisson</h3>

                    <p>
                        The total number of events \( N(T) \) in the interval \([0, T]\) follows a 
                        <b>binomial distribution</b>:
                    </p>
                    <div class="math-block">\[ N(T) \sim \text{Binomial}\left(n, \frac{\lambda T}{n}\right) \]</div>

                    <p>
                        As \( n \to \infty \) (equivalently, \( \Delta t \to 0 \)), this binomial distribution 
                        converges to a <b>Poisson distribution</b>:
                    </p>
                    <div class="math-block">\[ N(T) \xrightarrow{d} \text{Poisson}(\lambda T) \]</div>

                    <div style="background: rgba(36, 163, 225, 0.1); border-left: 4px solid #24a3e1; padding: 2rem; margin: 2rem 0;">
                        <h4 style="margin-top: 0; color: #24a3e1;">Poisson Limit Theorem</h4>
                        <p>
                            If \( X_n \sim \text{Binomial}(n, p_n) \) where \( np_n \to \lambda \) as \( n \to \infty \), then:
                        </p>
                        <div class="math-block">\[ P(X_n = k) \to \frac{\lambda^k e^{-\lambda}}{k!} \quad \text{as } n \to \infty \]</div>
                        <p>
                            In our case, \( p_n = \lambda T / n \), so \( np_n = \lambda T \), which remains constant 
                            as \( n \to \infty \). This ensures convergence to \( \text{Poisson}(\lambda T) \).
                        </p>
                    </div>

                    <h3>Algorithm Summary</h3>

                    <div style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 2rem; margin: 2rem 0; font-family: 'Monaco', 'Menlo', 'Consolas', monospace; font-size: 0.9rem; line-height: 1.8;">
                        <div style="color: #24a3e1; margin-bottom: 1rem;"><b>Algorithm: Simulate Poisson Process</b></div>
                        <div><b>Input:</b> Time interval T, rate λ, number of subintervals n</div>
                        <div><b>Output:</b> Event times and counts N(t)</div>
                        <div style="margin-top: 1rem;"><b>Procedure:</b></div>
                        <div style="margin-left: 2rem;">
                            1. Set Δt = T / n<br>
                            2. Set p = λ · Δt<br>
                            3. Initialize event_times = []<br>
                            4. Initialize N = 0<br>
                            5. For i = 1 to n:<br>
                            <div style="margin-left: 2rem;">
                                a. Generate U ~ Uniform(0, 1)<br>
                                b. If U < p:<br>
                                <div style="margin-left: 2rem;">
                                    - t = i · Δt<br>
                                    - Append t to event_times<br>
                                    - N = N + 1<br>
                                </div>
                            </div>
                            6. Return event_times and N
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container">
                <div class="section-number">04</div>

                <div class="content-wrapper">
                    <h2>Interactive Simulation</h2>
                    
                    <p>
                        Use the controls below to simulate a Poisson process. Adjust the rate parameter \( \lambda \) 
                        and observe how it affects the frequency and distribution of events.
                    </p>

                    <div style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 2rem; margin: 2rem 0;">
                        <h3 style="margin-top: 0;">Simulation Parameters</h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                            <div>
                                <label for="rateParam" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">
                                    Rate λ: <span id="rateValue" style="color: #24a3e1;">5.0</span> events per unit time
                                </label>
                                <input type="range" id="rateParam" min="1" max="20" value="5" step="0.5" 
                                    style="width: 100%;" oninput="updateRateValue(this.value)">
                            </div>
                            
                            <div>
                                <label for="timeInterval" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">
                                    Time Interval T: <span id="timeValue" style="color: #24a3e1;">1.0</span>
                                </label>
                                <input type="range" id="timeInterval" min="0.5" max="3" value="1" step="0.1" 
                                    style="width: 100%;" oninput="updateTimeValue(this.value)">
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                            <div>
                                <label for="numSubintervals" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">
                                    Subintervals n: <span id="subintervalsValue" style="color: #24a3e1;">5000</span>
                                </label>
                                <input type="range" id="numSubintervals" min="100" max="10000" value="5000" step="100" 
                                    style="width: 100%;" oninput="updateSubintervalsValue(this.value)">
                            </div>
                            
                            <div>
                                <label for="numSimulations" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">
                                    Number of Simulations: <span id="numSimsValue" style="color: #24a3e1;">1000</span>
                                </label>
                                <input type="range" id="numSimulations" min="100" max="5000" value="1000" step="100" 
                                    style="width: 100%;" oninput="updateNumSimsValue(this.value)">
                            </div>
                        </div>

                        <button class="btn" onclick="runSimulation()" style="width: 100%; margin-top: 1rem;">
                            Run Simulation
                        </button>
                    </div>

                    <div id="simulationResults" style="display: none; margin-top: 2rem;">
                        <h3>Simulation Results</h3>
                        
                        <div style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 2rem; margin: 2rem 0;">
                            <h4 style="margin-top: 0;">Sample Path Visualization</h4>
                            <p style="margin-bottom: 1rem;">
                                This shows a single realization of the Poisson process. The step function \( N(t) \) 
                                represents the cumulative count of events over time.
                            </p>
                            <canvas id="samplePathChart"></canvas>
                        </div>

                        <div style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 2rem; margin: 2rem 0;">
                            <h4 style="margin-top: 0;">Distribution of Event Counts</h4>
                            <p style="margin-bottom: 1rem;">
                                Histogram of \( N(T) \) from multiple simulations compared with the theoretical 
                                Poisson distribution \( \text{Poisson}(\lambda T) \).
                            </p>
                            <canvas id="distributionChart"></canvas>
                        </div>

                        <div style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 2rem; margin: 2rem 0;">
                            <h4 style="margin-top: 0;">Statistical Summary</h4>
                            <div id="statisticsSummary" style="font-family: 'Monaco', 'Menlo', 'Consolas', monospace; font-size: 0.95rem; line-height: 1.8;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container">
                <div class="section-number">05</div>

                <div class="content-wrapper">
                    <h2>Theoretical Properties of the Poisson Process</h2>
                    
                    <p>
                        The Poisson process \( \{N(t), t \geq 0\} \) with rate \( \lambda \) can be rigorously 
                        defined through three equivalent characterizations. We explore the axiomatic definition 
                        and derive key properties.
                    </p>

                    <h3>Axiomatic Definition</h3>

                    <div style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 2rem; margin: 2rem 0;">
                        <h4 style="margin-top: 0; color: #24a3e1;">Definition: Poisson Process</h4>
                        <p>
                            A counting process \( \{N(t), t \geq 0\} \) is a <b>Poisson process</b> with rate 
                            \( \lambda > 0 \) if:
                        </p>
                        <ol>
                            <li>\( N(0) = 0 \)</li>
                            <li><b>Independent increments:</b> For any \( 0 \leq t_1 < t_2 < \cdots < t_n \), 
                                the increments \( N(t_2) - N(t_1), N(t_3) - N(t_2), \ldots, N(t_n) - N(t_{n-1}) \) 
                                are independent</li>
                            <li><b>Stationary increments:</b> For any \( s < t \), the distribution of 
                                \( N(t) - N(s) \) depends only on \( t - s \)</li>
                            <li>For small \( h > 0 \):
                                <div class="math-block">\[ P(N(h) = 1) = \lambda h + o(h) \]</div>
                                <div class="math-block">\[ P(N(h) \geq 2) = o(h) \]</div>
                                where \( o(h) \) denotes a term such that \( \lim_{h \to 0} o(h)/h = 0 \)
                            </li>
                        </ol>
                    </div>

                    <h3>Key Properties</h3>

                    <div class="content-columns">
                        <div class="column">
                            <h4>1. Poisson Distribution</h4>
                            <p>
                                For any \( t \geq 0 \):
                            </p>
                            <div class="math-block">\[ N(t) \sim \text{Poisson}(\lambda t) \]</div>
                            <div class="math-block">\[ P(N(t) = k) = \frac{(\lambda t)^k e^{-\lambda t}}{k!} \]</div>
                            <p>
                                <b>Expected value:</b> \( E[N(t)] = \lambda t \)<br>
                                <b>Variance:</b> \( \text{Var}(N(t)) = \lambda t \)
                            </p>
                        </div>

                        <div class="column">
                            <h4>2. Independent & Stationary Increments</h4>
                            <p>
                                Events in non-overlapping intervals are independent, and the distribution of 
                                \( N(t) - N(s) \) depends only on \( t - s \):
                            </p>
                            <div class="math-block">\[ N(t) - N(s) \sim \text{Poisson}(\lambda(t-s)) \]</div>
                            <p>
                                This means past events don't influence future ones, and the process is 
                                homogeneous in time.
                            </p>
                        </div>
                    </div>

                    <div class="content-columns" style="margin-top: 2rem;">
                        <div class="column">
                            <h4>3. Exponential Interarrival Times</h4>
                            <p>
                                The times between successive events are independent and exponentially distributed:
                            </p>
                            <div class="math-block">\[ T_i \sim \text{Exp}(\lambda), \quad E[T_i] = \frac{1}{\lambda} \]</div>
                        </div>

                        <div class="column">
                            <h4>4. Memoryless Property</h4>
                            <p>
                                For any \( s, t \geq 0 \):
                            </p>
                            <div class="math-block">\[ P(T > s + t \mid T > s) = P(T > t) \]</div>
                            <p>
                                The process "forgets" how long we've been waiting: the remaining waiting time 
                                has the same distribution as the original waiting time.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container">
                <div class="section-number">06</div>

                <div class="content-wrapper">
                    <h2>Interpretation of the Rate Parameter λ</h2>
                    
                    <p>
                        The rate parameter \( \lambda \) is the most important characteristic of a Poisson process. 
                        It has multiple interpretations that provide intuition about the process.
                    </p>

                    <h3>Multiple Interpretations of λ</h3>

                    <div class="content-columns">
                        <div class="column">
                            <h4>1. Average Event Rate</h4>
                            <p>
                                \( \lambda \) represents the <b>average number of events per unit time</b>:
                            </p>
                            <div class="math-block">\[ \lambda = \frac{E[N(t)]}{t} \]</div>
                            <p>
                                <b>Example:</b> If \( \lambda = 5 \), we expect 5 events per second on average.
                            </p>
                        </div>

                        <div class="column">
                            <h4>2. Reciprocal of Mean Waiting Time</h4>
                            <p>
                                The expected time between successive events is:
                            </p>
                            <div class="math-block">\[ E[T_i] = \frac{1}{\lambda} \quad \Rightarrow \quad \lambda = \frac{1}{E[\text{interarrival time}]} \]</div>
                            <p>
                                <b>Example:</b> If events occur every 0.2 seconds on average, then \( \lambda = 5 \).
                            </p>
                        </div>
                    </div>

                    <h3>Estimating λ and Its Impact</h3>

                    <p>
                        From observed data, we can estimate \( \lambda \) using: 
                        \( \hat{\lambda} = N(T) / T \) (total events divided by observation time).
                    </p>

                    <p>
                        The value of \( \lambda \) determines the process behavior: small \( \lambda \) yields 
                        rare events with long gaps, while large \( \lambda \) produces frequent events with short 
                        interarrival times. The variance equals the mean (\( \lambda t \)), which is a distinctive 
                        property of the Poisson distribution.
                    </p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container">
                <div class="section-number">07</div>

                <div class="content-wrapper">
                    <h2>Practical Applications</h2>
                    
                    <p>
                        Poisson processes model various real-world phenomena:
                    </p>

                    <ul>
                        <li><b>Network security:</b> Failed login attempts, intrusion detection (baseline rate \( \lambda_0 \) vs. attack rate \( \lambda_1 \))</li>
                        <li><b>Traffic analysis:</b> Packet arrivals, DoS detection through rate monitoring</li>
                        <li><b>Risk assessment:</b> Security incidents, calculating probability of future events</li>
                        <li><b>Queue management:</b> Customer arrivals, service system design</li>
                    </ul>

                    <p>
                        <b>Note:</b> Real-world data may violate Poisson assumptions (e.g., non-constant rates, 
                        bursty arrivals). Extensions like non-homogeneous Poisson processes can handle time-varying rates.
                    </p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container">
                <div class="section-number">08</div>

                <div class="content-wrapper">
                    <h2>Conclusion</h2>
                    
                    <p>
                        Through this assignment, we have explored the <b>Poisson process</b> through simulation and theory:
                    </p>

                    <ul>
                        <li>
                            <b>Simulation method:</b> Dividing time into \( n \) subintervals and generating events 
                            with probability \( \lambda/n \) approximates the continuous Poisson process
                        </li>
                        <li>
                            <b>Convergence:</b> As \( n \to \infty \), \( \text{Binomial}(n, \lambda T/n) \to \text{Poisson}(\lambda T) \)
                        </li>
                        <li>
                            <b>Key properties:</b> Independent increments, stationary increments, memorylessness, 
                            and Poisson-distributed counts
                        </li>
                        <li>
                            <b>Rate parameter \( \lambda \):</b> Represents average events per unit time and 
                            reciprocal of mean interarrival time
                        </li>
                        <li>
                            <b>Applications:</b> Network traffic, security monitoring, queueing systems, and risk assessment
                        </li>
                    </ul>

                    <div style="background: rgba(36, 163, 225, 0.1); border-left: 4px solid #24a3e1; padding: 2rem; margin: 2rem 0;">
                        <p style="margin: 0;">
                            The Poisson process exemplifies how <b>simple discrete mechanisms converge to complex 
                            continuous phenomena</b>. Our simulation demonstrates this principle: the discrete 
                            approximation converges to the continuous Poisson process, with event counts matching 
                            theoretical predictions and exhibiting the characteristic memoryless property.
                        </p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-info">
                    <p class="footer-name">Andrea Altomare</p>
                    <p class="footer-detail">2199451</p>
                    <p class="footer-detail">altomare.2199451@studenti.uniroma1.it</p>
                </div>
                <div class="footer-copyright">
                    <p>&copy; 2025 Andrea Altomare</p>
                </div>
            </div>
        </div>
    </footer>

    <script>
        function toggleMenu() {
            const mobileMenu = document.querySelector('.mobile-menu');
            const hamburger = document.querySelector('.hamburger');
            mobileMenu.classList.toggle('active');
            hamburger.classList.toggle('active');
        }

        // Update parameter display values
        function updateRateValue(val) {
            document.getElementById('rateValue').textContent = parseFloat(val).toFixed(1);
        }

        function updateTimeValue(val) {
            document.getElementById('timeValue').textContent = parseFloat(val).toFixed(1);
        }

        function updateSubintervalsValue(val) {
            document.getElementById('subintervalsValue').textContent = val;
        }

        function updateNumSimsValue(val) {
            document.getElementById('numSimsValue').textContent = val;
        }

        // Poisson PMF
        function poissonPMF(k, lambda) {
            if (lambda <= 0) return 0;
            if (k < 0) return 0;
            
            // Use log to avoid overflow
            let logProb = k * Math.log(lambda) - lambda - logFactorial(k);
            return Math.exp(logProb);
        }

        function logFactorial(n) {
            if (n <= 1) return 0;
            let result = 0;
            for (let i = 2; i <= n; i++) {
                result += Math.log(i);
            }
            return result;
        }

        // Simulate a single Poisson process
        function simulatePoissonProcess(T, lambda, n) {
            const dt = T / n;
            const p = lambda * dt;
            const eventTimes = [];
            
            for (let i = 0; i < n; i++) {
                if (Math.random() < p) {
                    eventTimes.push((i + 1) * dt);
                }
            }
            
            return {
                eventTimes: eventTimes,
                count: eventTimes.length
            };
        }

        // Global chart objects
        let samplePathChart = null;
        let distributionChart = null;

        // Run simulation
        function runSimulation() {
            const lambda = parseFloat(document.getElementById('rateParam').value);
            const T = parseFloat(document.getElementById('timeInterval').value);
            const n = parseInt(document.getElementById('numSubintervals').value);
            const numSims = parseInt(document.getElementById('numSimulations').value);

            // Show results section
            document.getElementById('simulationResults').style.display = 'block';

            // Simulate once for sample path
            const sampleRun = simulatePoissonProcess(T, lambda, n);
            
            // Simulate many times for distribution
            const counts = [];
            for (let i = 0; i < numSims; i++) {
                const result = simulatePoissonProcess(T, lambda, n);
                counts.push(result.count);
            }

            // Calculate statistics
            const meanCount = counts.reduce((a, b) => a + b, 0) / counts.length;
            const variance = counts.reduce((sum, x) => sum + Math.pow(x - meanCount, 2), 0) / counts.length;
            const theoreticalMean = lambda * T;
            const theoreticalVariance = lambda * T;

            // Display statistics
            const statsHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div><b>Empirical Mean:</b></div><div>${meanCount.toFixed(3)}</div>
                    <div><b>Theoretical Mean (λT):</b></div><div>${theoreticalMean.toFixed(3)}</div>
                    <div><b>Empirical Variance:</b></div><div>${variance.toFixed(3)}</div>
                    <div><b>Theoretical Variance (λT):</b></div><div>${theoreticalVariance.toFixed(3)}</div>
                    <div><b>Number of Events (sample):</b></div><div>${sampleRun.count}</div>
                    <div><b>Estimated λ̂:</b></div><div>${(meanCount / T).toFixed(3)}</div>
                    <div><b>True λ:</b></div><div>${lambda.toFixed(3)}</div>
                </div>
            `;
            document.getElementById('statisticsSummary').innerHTML = statsHTML;

            // Plot sample path
            plotSamplePath(sampleRun.eventTimes, T);

            // Plot distribution
            plotDistribution(counts, lambda * T);

            // Scroll to results
            document.getElementById('simulationResults').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function plotSamplePath(eventTimes, T) {
            const canvas = document.getElementById('samplePathChart');
            const ctx = canvas.getContext('2d');

            // Build step function data
            const times = [0];
            const counts = [0];
            
            for (let i = 0; i < eventTimes.length; i++) {
                times.push(eventTimes[i]);
                counts.push(i + 1);
            }
            times.push(T);
            counts.push(eventTimes.length);

            // Create step function points
            const data = [];
            for (let i = 0; i < times.length - 1; i++) {
                data.push({ x: times[i], y: counts[i] });
                data.push({ x: times[i + 1], y: counts[i] });
            }
            data.push({ x: times[times.length - 1], y: counts[counts.length - 1] });

            if (samplePathChart) {
                samplePathChart.destroy();
            }

            samplePathChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'N(t) - Event Count',
                        data: data,
                        borderColor: '#24a3e1',
                        backgroundColor: 'rgba(36, 163, 225, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        stepped: false,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2.5,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time t',
                                color: '#e8e8e8'
                            },
                            ticks: { color: '#e8e8e8' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Events N(t)',
                                color: '#e8e8e8'
                            },
                            ticks: { 
                                color: '#e8e8e8',
                                stepSize: 1
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { color: '#e8e8e8' }
                        }
                    }
                }
            });
        }

        function plotDistribution(counts, lambdaT) {
            const canvas = document.getElementById('distributionChart');
            const ctx = canvas.getContext('2d');

            // Create histogram
            const maxCount = Math.max(...counts);
            const minCount = Math.min(...counts);
            const bins = {};
            
            for (let count of counts) {
                bins[count] = (bins[count] || 0) + 1;
            }

            // Normalize to get empirical probabilities
            const numSims = counts.length;
            const empiricalProbs = {};
            for (let k in bins) {
                empiricalProbs[k] = bins[k] / numSims;
            }

            // Calculate theoretical Poisson probabilities
            const theoreticalProbs = {};
            const range = Math.max(maxCount - minCount, 20);
            const start = Math.max(0, Math.floor(lambdaT - 3 * Math.sqrt(lambdaT)));
            const end = Math.ceil(lambdaT + 3 * Math.sqrt(lambdaT));
            
            for (let k = start; k <= end; k++) {
                theoreticalProbs[k] = poissonPMF(k, lambdaT);
            }

            // Prepare data for chart
            const labels = [];
            const empiricalData = [];
            const theoreticalData = [];

            for (let k = start; k <= end; k++) {
                labels.push(k.toString());
                empiricalData.push(empiricalProbs[k] || 0);
                theoreticalData.push(theoreticalProbs[k]);
            }

            if (distributionChart) {
                distributionChart.destroy();
            }

            distributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Empirical (Simulated)',
                            data: empiricalData,
                            backgroundColor: 'rgba(36, 163, 225, 0.6)',
                            borderColor: '#24a3e1',
                            borderWidth: 1
                        },
                        {
                            label: 'Theoretical Poisson(λT)',
                            data: theoreticalData,
                            type: 'line',
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            borderWidth: 2,
                            pointRadius: 3,
                            pointBackgroundColor: '#ef4444',
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2.5,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Number of Events k',
                                color: '#e8e8e8'
                            },
                            ticks: { color: '#e8e8e8' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Probability P(N(T) = k)',
                                color: '#e8e8e8'
                            },
                            ticks: { color: '#e8e8e8' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { color: '#e8e8e8' }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>


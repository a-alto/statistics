<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 4 | Statistics - Sapienza University of Rome</title>
    <link rel="stylesheet" href="/statistics/styles.css">
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(','\\)'], ['$', '$']],
                displayMath: [['\\[','\\]'], ['$$','$$']]
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <nav>
        <div class="nav-container">
            <a href="/statistics/index.html" class="logo">STATISTICS</a>
            <ul class="nav-menu">
                <li><a href="/statistics/index.html#home">Home</a></li>
                <li><a href="/statistics/hmwk2.html">HMWK 2</a></li>
                <li><a href="/statistics/hmwk3.html">HMWK 3</a></li>
                <li><a href="/statistics/hmwk4.html">HMWK 4</a></li>
            </ul>
            <div class="hamburger" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        <div class="mobile-menu">
            <ul>
                <li><a href="/statistics/index.html#home" onclick="toggleMenu()">Home</a></li>
                <li><a href="/statistics/hmwk2.html" onclick="toggleMenu()">HMWK 2</a></li>
                <li><a href="/statistics/hmwk3.html" onclick="toggleMenu()">HMWK 3</a></li>
                <li><a href="/statistics/hmwk4.html" onclick="toggleMenu()">HMWK 4</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <section class="hero-section">
            <div class="container">
                <div class="section-number">01</div>
                <div class="section-label">HOMEWORK 4</div>
                <div class="hero-content">
                    <h1>Breaking RSA with Frequency Analysis</h1>
                    <div class="hero-underline"></div>
                    <p class="hero-description">
                        While RSA is typically broken through factorization of the modulus \( n = p \times q \),
                        we can also apply statistical methods when RSA is used improperly. In this experiment,
                        we use <b>frequency analysis</b> to break character-by-character RSA encryption with small keys.
                        
                        <div class="math-block">\[ c_i = m_i^e \mod n \]</div>
                        
                        When each character is encrypted independently with small keys, the ciphertext preserves
                        statistical patterns from the plaintext. By comparing the frequency distribution of
                        encrypted values to expected character frequencies, we can reverse-engineer the encryption.
                        
                        <div class="math-block">\[ \chi^2 = \sum_{i} \frac{(O_i - E_i)^2}{E_i} \]</div>
                        
                        This demonstrates why proper RSA implementation requires padding schemes (like OAEP) and
                        sufficiently large keys to prevent statistical attacks.
                    </p>
                </div>
                <div class="scroll-indicator">
                    <div class="line"></div>
                    <div class="line"></div>
                    <div class="line"></div>
                    <div class="line"></div>
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container">
                <div class="section-number">02</div>

                <div class="content-wrapper">
                    <h2>RSA Encryption with Frequency Analysis Attack</h2>
                    <p>
                        In this experiment, we'll encrypt text using small RSA keys (character by character) and then
                        use statistical frequency analysis to break the encryption without knowing the private key.
                    </p>

                    <h3>Step 1: Input Text and Set RSA Parameters</h3>
                    <p>
                        Enter or modify the text below. For best results, use text in English with sufficient length
                        (at least a few paragraphs).
                    </p>

                    <div style="margin-top: 2rem; margin-bottom: 1rem;">
                        <label for="plaintextInput" style="font-weight: 500;">Plaintext:</label><br>
                        <textarea id="plaintextInput" rows="8" style="width: 100%; margin-top: 0.5rem; margin-bottom: 1rem; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 0.75rem 1rem; color: #e8e8e8; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace; font-size: 0.95rem; outline: none; resize: vertical; min-height: 150px; line-height: 1.6;">Cryptography is the practice and study of techniques for secure communication in the presence of adversarial behavior. More generally, cryptography is about constructing and analyzing protocols that prevent third parties or the public from reading private messages. Modern cryptography exists at the intersection of the disciplines of mathematics, computer science, information security, electrical engineering, digital signal processing, physics, and others. Core concepts related to information security are also central to cryptography. Practical applications of cryptography include electronic commerce, chip-based payment cards, digital currencies, computer passwords, and military communications. Cryptography prior to the modern age was effectively synonymous with encryption, converting information from a readable state to apparent nonsense. The originator of an encrypted message shared the decoding technique only with intended recipients to preclude access from adversaries. The cryptography literature often uses the names Alice and Bob for the sender and receiver of messages respectively. Since the development of rotor cipher machines in World War I and the advent of computers in World War II, cryptography methods have become increasingly complex and their applications more varied.</textarea>
                    </div>

                    <div style="display: flex; gap: 1.5rem; align-items: center; margin-bottom: 1.5rem; flex-wrap: wrap;">
                        <div>
                            <label for="rsaPrime1" style="font-weight: 500;">Prime p:</label>
                            <input type="number" id="rsaPrime1" value="61" min="3" max="997" style="width:80px; margin-left: 0.5em; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 0.5rem; color: #e8e8e8; font-family: 'DM Sans', sans-serif; font-size: 0.95rem; outline: none;">
                        </div>
                        <div>
                            <label for="rsaPrime2" style="font-weight: 500;">Prime q:</label>
                            <input type="number" id="rsaPrime2" value="53" min="3" max="997" style="width:80px; margin-left: 0.5em; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 0.5rem; color: #e8e8e8; font-family: 'DM Sans', sans-serif; font-size: 0.95rem; outline: none;">
                        </div>
                        <button class="btn" onclick="encryptRSAText()">Encrypt with RSA</button>
                    </div>

                    <div style="margin-bottom: 2rem;">
                        <label for="ciphertextOutput" style="font-weight: 500;">Encrypted Output (RSA ciphertext):</label><br>
                        <textarea id="ciphertextOutput" rows="6" readonly style="width: 100%; margin-top: 0.5rem; background: rgba(0, 0, 0, 0.2); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; padding: 0.75rem 1rem; color: #9ca3af; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace; font-size: 0.85rem; outline: none; resize: vertical; min-height: 120px; line-height: 1.6;"></textarea>
                    </div>

                    <div style="margin-bottom: 2rem;">
                        <h4>RSA Parameters Used:</h4>
                        <table class="data-table" style="max-width: 600px;">
                            <thead>
                                <tr>
                                    <th>Parameter</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>p (prime)</td>
                                    <td id="displayP">-</td>
                                </tr>
                                <tr>
                                    <td>q (prime)</td>
                                    <td id="displayQ">-</td>
                                </tr>
                                <tr>
                                    <td>n = p × q</td>
                                    <td id="displayN">-</td>
                                </tr>
                                <tr>
                                    <td>φ(n) = (p-1)(q-1)</td>
                                    <td id="displayPhi">-</td>
                                </tr>
                                <tr>
                                    <td>e (public exponent)</td>
                                    <td id="displayE">-</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>Step 2: Frequency Analysis</h3>
                    <p>
                        Now we'll analyze the frequency distribution of the encrypted values and compare it with
                        the expected distribution of English characters.
                    </p>

                    <div style="margin-bottom: 1.5rem;">
                        <button class="btn" onclick="analyzeFrequencies()">Show Frequency Analysis</button>
                    </div>

                    <div id="frequencyCharts" style="display: flex; flex-wrap: wrap; gap: 2rem; margin-top: 1.5rem; margin-bottom: 2rem;">
                        <div style="flex:1; min-width:450px;">
                            <b>Ciphertext Value Frequencies:</b>
                            <canvas id="ciphertextFreqChart" style="width: 100% !important; height: 350px !important;"></canvas>
                        </div>
                        <div style="flex:1; min-width:450px;">
                            <b>Expected English Letter Frequencies:</b>
                            <canvas id="expectedFreqChart" style="width: 100% !important; height: 350px !important;"></canvas>
                        </div>
                    </div>

                    <h3>Step 3: Break the Cipher</h3>
                    <p>
                        Using frequency analysis and trying different mappings, we'll attempt to decrypt the message
                        without factoring \( n \) or knowing the private key \( d \).
                    </p>

                    <div style="margin-bottom: 1rem;">
                        <button class="btn" onclick="breakRSACipher()">Break RSA Cipher (Frequency Attack)</button>
                    </div>

                    <div style="margin-bottom: 2rem;">
                        <label for="attackProgress" style="font-weight: 500;">Attack Progress Log:</label><br>
                        <textarea id="attackProgress" rows="10" readonly style="width: 100%; margin-top: 0.5rem; background: rgba(0, 0, 0, 0.2); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; padding: 0.75rem 1rem; color: #9ca3af; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace; font-size: 0.9rem; outline: none; resize: vertical; min-height: 200px; line-height: 1.6;"></textarea>
                    </div>

                    <div style="margin-bottom: 2rem;">
                        <label for="decryptedOutput" style="font-weight: 500;">Decrypted Text:</label><br>
                        <textarea id="decryptedOutput" rows="8" readonly style="width: 100%; margin-top: 0.5rem; background: rgba(0, 0, 0, 0.25); border: 2px solid rgba(34, 197, 94, 0.3); border-radius: 6px; padding: 0.75rem 1rem; color: #4ade80; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace; font-size: 0.95rem; font-weight: 500; outline: none; resize: vertical; min-height: 150px; line-height: 1.6;"></textarea>
                    </div>

                    <h3>Understanding the Attack</h3>
                    <p>
                        This attack works because:
                        <ul>
                            <li><b>Deterministic encryption</b>: Each character always encrypts to the same value</li>
                            <li><b>Small key space</b>: With small primes, there are limited possible encrypted values</li>
                            <li><b>Preserved patterns</b>: Character frequency distribution is maintained in ciphertext</li>
                            <li><b>Known plaintext distribution</b>: We know the expected frequency of English letters</li>
                        </ul>

                        Real-world RSA prevents this by:
                        <ul>
                            <li>Using very large keys (2048+ bits)</li>
                            <li>Encrypting large blocks instead of individual characters</li>
                            <li>Using padding schemes (OAEP) that add randomness</li>
                            <li>Never encrypting the same message the same way twice</li>
                        </ul>
                    </p>

                    <script>
                        // English letter frequencies (percentage)
                        const englishFreq = {
                            'a': 8.167, 'b': 1.492, 'c': 2.782, 'd': 4.253, 'e': 12.702,
                            'f': 2.228, 'g': 2.015, 'h': 6.094, 'i': 6.966, 'j': 0.153,
                            'k': 0.772, 'l': 4.025, 'm': 2.406, 'n': 6.749, 'o': 7.507,
                            'p': 1.929, 'q': 0.095, 'r': 5.987, 's': 6.327, 't': 9.056,
                            'u': 2.758, 'v': 0.978, 'w': 2.360, 'x': 0.150, 'y': 1.974,
                            'z': 0.074, ' ': 13.0
                        };

                        let rsaParams = {};
                        let encryptedData = [];
                        let ciphertextFreqChart = null;
                        let expectedFreqChart = null;

                        // Helper functions
                        function isPrime(n) {
                            if (n < 2) return false;
                            for (let i = 2; i * i <= n; i++) {
                                if (n % i === 0) return false;
                            }
                            return true;
                        }

                        function gcd(a, b) {
                            while (b !== 0) {
                                [a, b] = [b, a % b];
                            }
                            return a;
                        }

                        function modInverse(e, phi) {
                            let [t, newt] = [0, 1];
                            let [r, newr] = [phi, e];
                            while (newr !== 0) {
                                let quotient = Math.floor(r / newr);
                                [t, newt] = [newt, t - quotient * newt];
                                [r, newr] = [newr, r - quotient * newr];
                            }
                            if (r > 1) return null;
                            if (t < 0) t += phi;
                            return t;
                        }

                        function modPow(base, exp, mod) {
                            let result = 1;
                            base = base % mod;
                            while (exp > 0) {
                                if (exp % 2 === 1) {
                                    result = (result * base) % mod;
                                }
                                exp = Math.floor(exp / 2);
                                base = (base * base) % mod;
                            }
                            return result;
                        }

                        // Encrypt text with RSA
                        function encryptRSAText() {
                            const text = document.getElementById('plaintextInput').value;
                            const p = parseInt(document.getElementById('rsaPrime1').value);
                            const q = parseInt(document.getElementById('rsaPrime2').value);

                            if (!isPrime(p) || !isPrime(q) || p === q) {
                                alert('Both p and q must be different prime numbers!');
                                return;
                            }

                            const n = p * q;
                            const phi = (p - 1) * (q - 1);

                            // Find suitable e
                            let e = 65537;
                            if (e >= phi || gcd(e, phi) !== 1) {
                                e = 3;
                                while (e < phi && gcd(e, phi) !== 1) {
                                    e += 2;
                                }
                            }

                            if (e >= phi) {
                                alert('Primes too small! Choose larger values.');
                                return;
                            }

                            // Store RSA parameters
                            rsaParams = { p, q, n, phi, e };

                            // Encrypt each character
                            encryptedData = [];
                            let ciphertext = [];
                            
                            for (let char of text) {
                                const charCode = char.charCodeAt(0);
                                if (charCode >= n) {
                                    alert(`Character value ${charCode} >= n (${n}). Use larger primes!`);
                                    return;
                                }
                                const encrypted = modPow(charCode, e, n);
                                encryptedData.push({ original: char, code: charCode, encrypted });
                                ciphertext.push(encrypted);
                            }

                            // Display results
                            document.getElementById('ciphertextOutput').value = ciphertext.join(' ');
                            document.getElementById('displayP').textContent = p;
                            document.getElementById('displayQ').textContent = q;
                            document.getElementById('displayN').textContent = n;
                            document.getElementById('displayPhi').textContent = phi;
                            document.getElementById('displayE').textContent = e;

                            // Clear previous results
                            document.getElementById('decryptedOutput').value = '';
                            document.getElementById('attackProgress').value = '';
                        }

                        // Analyze frequencies
                        function analyzeFrequencies() {
                            if (encryptedData.length === 0) {
                                alert('Please encrypt text first!');
                                return;
                            }

                            // Count frequency of each encrypted value
                            const freqMap = {};
                            for (let item of encryptedData) {
                                freqMap[item.encrypted] = (freqMap[item.encrypted] || 0) + 1;
                            }

                            // Convert to percentages
                            const total = encryptedData.length;
                            const freqPercent = {};
                            for (let key in freqMap) {
                                freqPercent[key] = (freqMap[key] / total) * 100;
                            }

                            // Sort by frequency
                            const sortedFreq = Object.entries(freqPercent)
                                .sort((a, b) => b[1] - a[1])
                                .slice(0, 30); // Top 30

                            // Plot ciphertext frequencies
                            if (ciphertextFreqChart) ciphertextFreqChart.destroy();
                            const ctx1 = document.getElementById('ciphertextFreqChart').getContext('2d');
                            ciphertextFreqChart = new Chart(ctx1, {
                                type: 'bar',
                                data: {
                                    labels: sortedFreq.map(x => x[0]),
                                    datasets: [{
                                        label: 'Frequency (%)',
                                        data: sortedFreq.map(x => x[1]),
                                        backgroundColor: '#3af',
                                        borderColor: '#111b',
                                        borderWidth: 1
                                    }]
                                },
                                options: {
                                    responsive: false,
                                    plugins: { legend: { display: false } },
                                    scales: {
                                        x: { title: {display: true, text: 'Encrypted Value'}, grid: {display:false} },
                                        y: { beginAtZero: true, title: {display:true, text:'Frequency (%)'} }
                                    }
                                }
                            });

                            // Plot expected English frequencies
                            if (expectedFreqChart) expectedFreqChart.destroy();
                            const sortedEnglish = Object.entries(englishFreq)
                                .sort((a, b) => b[1] - a[1]);

                            const ctx2 = document.getElementById('expectedFreqChart').getContext('2d');
                            expectedFreqChart = new Chart(ctx2, {
                                type: 'bar',
                                data: {
                                    labels: sortedEnglish.map(x => x[0] === ' ' ? 'SPACE' : x[0]),
                                    datasets: [{
                                        label: 'Frequency (%)',
                                        data: sortedEnglish.map(x => x[1]),
                                        backgroundColor: '#faa',
                                        borderColor: '#111b',
                                        borderWidth: 1
                                    }]
                                },
                                options: {
                                    responsive: false,
                                    plugins: { legend: { display: false } },
                                    scales: {
                                        x: { title: {display: true, text: 'Character'}, grid: {display:false} },
                                        y: { beginAtZero: true, title: {display:true, text:'Frequency (%)'} }
                                    }
                                }
                            });
                        }

                        // Break RSA cipher using frequency analysis
                        function breakRSACipher() {
                            if (encryptedData.length === 0) {
                                alert('Please encrypt text first!');
                                return;
                            }

                            let log = '=== RSA Frequency Analysis Attack ===\n\n';
                            log += 'Step 1: Analyzing ciphertext frequency distribution...\n';

                            // Count frequencies
                            const freqMap = {};
                            for (let item of encryptedData) {
                                freqMap[item.encrypted] = (freqMap[item.encrypted] || 0) + 1;
                            }

                            const total = encryptedData.length;
                            const sortedCipherFreq = Object.entries(freqMap)
                                .map(([val, count]) => ({ value: parseInt(val), freq: (count/total)*100, count }))
                                .sort((a, b) => b.freq - a.freq);

                            log += `  Found ${sortedCipherFreq.length} unique encrypted values\n`;
                            log += `  Most common: ${sortedCipherFreq[0].value} (${sortedCipherFreq[0].freq.toFixed(2)}%)\n\n`;

                            log += 'Step 2: Matching with English character frequencies...\n';

                            // Create mapping from most frequent ciphertext to most frequent characters
                            const sortedEnglish = Object.entries(englishFreq)
                                .sort((a, b) => b[1] - a[1]);

                            const mapping = {};
                            for (let i = 0; i < Math.min(sortedCipherFreq.length, sortedEnglish.length); i++) {
                                mapping[sortedCipherFreq[i].value] = sortedEnglish[i][0];
                                if (i < 10) {
                                    log += `  ${sortedCipherFreq[i].value} → '${sortedEnglish[i][0]}' (${sortedCipherFreq[i].freq.toFixed(2)}% ≈ ${sortedEnglish[i][1]}%)\n`;
                                }
                            }

                            log += '\nStep 3: Applying frequency-based mapping...\n';

                            // Decrypt using mapping
                            let decrypted = '';
                            let unmapped = 0;
                            for (let item of encryptedData) {
                                if (mapping[item.encrypted]) {
                                    decrypted += mapping[item.encrypted];
                                } else {
                                    decrypted += '?';
                                    unmapped++;
                                }
                            }

                            log += `  Mapped: ${encryptedData.length - unmapped} characters\n`;
                            log += `  Unmapped: ${unmapped} characters\n\n`;

                            log += '✓ Attack complete!\n';
                            log += 'Note: This attack works due to small key size and character-by-character encryption.\n';
                            log += 'Real RSA with proper padding and large keys is immune to frequency analysis.';

                            document.getElementById('attackProgress').value = log;
                            document.getElementById('decryptedOutput').value = decrypted;
                        }

                        function toggleMenu() {
                            const mobileMenu = document.querySelector('.mobile-menu');
                            const hamburger = document.querySelector('.hamburger');
                            mobileMenu.classList.toggle('active');
                            hamburger.classList.toggle('active');
                        }
                    </script>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-info">
                    <p class="footer-name">Andrea Altomare</p>
                    <p class="footer-detail">2199451</p>
                    <p class="footer-detail">altomare.2199451@studenti.uniroma1.it</p>
                </div>
                <div class="footer-copyright">
                    <p>&copy; 2025 Andrea Altomare</p>
                </div>
            </div>
        </div>
    </footer>
</body>
</html>

